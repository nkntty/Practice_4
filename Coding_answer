Question1. When using an iterator on an STL list of integers, which of the following will advance the iterator to the next item?
Answer: a. itr++

Explanation: itr++ advances the iterator to the next element in STL containers like std::list.

Question2. Which data structure stores things in reverse chronological order (LIFO)?
Answer: c. Stack

Explanation: Stack operates on Last-In, First-Out principle.

Question3. Which of the following would cause a class to be abstract?
Answer: c. virtual void func()=0

Explanation: This is a pure virtual function and makes a class abstract.

Question4. Derived class wants to access base class's private data member. What do you write in Derived::func(int x)?
Base::func(x);
Explanation: Since val is private in Base, you can only modify it via public functions of Base. Base::func(x) does exactly that.

Question5
5. Determine if a BSTNode is a left or right child of its parent
Assuming each node has a parent pointer:

if (node->parent->left == node)
    std::cout << "Left child";
else if (node->parent->right == node)
    std::cout << "Right child";
________________________________________________________________________________________________________________________________________________________________________________________________
Question6. Sort unsorted linked list in O(N log N) time
You can use merge sort for linked lists:


ListNode* mergeSort(ListNode* head);
// Split list into halves, recursively sort, and merge

// OR, if copying is allowed and memory is sufficient:
std::vector<int> values;
while (head != nullptr) {
    values.push_back(head->val);
    head = head->next;
}
std::sort(values.begin(), values.end());
// Rebuild or print sorted list
____________________________________________________________________________________________________________________________________________________________________________________
Question7

❌ What’s missing (and why it matters):
You're not checking if a subtree below has already returned -1, meaning it’s unbalanced. If a left or right subtree is unbalanced, you must propagate -1 up, not use its height in further comparisons.

✅ Corrected version:

int checkHeight(Node* root){
    if (root == nullptr) return 0;

    int leftHeight = checkHeight(root->left);
    if (leftHeight == -1) return -1; // Left subtree unbalanced

    int rightHeight = checkHeight(root->right);
    if (rightHeight == -1) return -1; // Right subtree unbalanced

    if (abs(leftHeight - rightHeight) > 1)
        return -1; // Current node unbalanced

    return 1 + std::max(leftHeight, rightHeight);
}



________________________________________________________________________________________________________________________________________
❌Question8

❗ Minor Fixes Needed:
1. Output Formatting (Missing Tab)
You're missing a \t (tab) between the number and the name when writing to the file:

fout << itr.num << '\t' << itr.name << endl;
Without the tab, the output won't match the original format (as shown in the question), which uses a tab to separate columns.

2. Pass comparator by const reference
Your compare() function should take const references to avoid unnecessary copies:


#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
using namespace std;

struct data {
    int num;
    string name;
};

bool compare(const data& d1, const data& d2) {
    return d1.num < d2.num;
}

int main() {
    ifstream fin("input.txt");
    vector<data> input;
    int n;
    string s;

    while (fin >> n >> s) {
        input.push_back({n, s});
    }
    fin.close();

    sort(input.begin(), input.end(), compare);

    ofstream fout("input.txt");
    for (auto& itr : input) {
        fout << itr.num << '\t' << itr.name << endl;
    }
    fout.close();

    return 0;
}

