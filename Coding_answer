Question1. When using an iterator on an STL list of integers, which of the following will advance the iterator to the next item?
Answer: a. itr++

Explanation: itr++ advances the iterator to the next element in STL containers like std::list.

Question2. Which data structure stores things in reverse chronological order (LIFO)?
Answer: c. Stack

Explanation: Stack operates on Last-In, First-Out principle.

Question3. Which of the following would cause a class to be abstract?
Answer: c. virtual void func()=0

Explanation: This is a pure virtual function and makes a class abstract.

Question4. Derived class wants to access base class's private data member. What do you write in Derived::func(int x)?
Base::func(x);
Explanation: Since val is private in Base, you can only modify it via public functions of Base. Base::func(x) does exactly that.

Question5
5. Determine if a BSTNode is a left or right child of its parent
Assuming each node has a parent pointer:

if (node->parent->left == node)
    std::cout << "Left child";
else if (node->parent->right == node)
    std::cout << "Right child";
________________________________________________________________________________________________________________________________________________________________________________________________
Question6. Sort unsorted linked list in O(N log N) time
You can use merge sort for linked lists:


ListNode* mergeSort(ListNode* head);
// Split list into halves, recursively sort, and merge

// OR, if copying is allowed and memory is sufficient:
std::vector<int> values;
while (head != nullptr) {
    values.push_back(head->val);
    head = head->next;
}
std::sort(values.begin(), values.end());
// Rebuild or print sorted list
____________________________________________________________________________________________________________________________________________________________________________________
Question7

❌ What’s missing (and why it matters):
You're not checking if a subtree below has already returned -1, meaning it’s unbalanced. If a left or right subtree is unbalanced, you must propagate -1 up, not use its height in further comparisons.

✅ Corrected version:

int checkHeight(Node* root){
    if (root == nullptr) return 0;

    int leftHeight = checkHeight(root->left);
    if (leftHeight == -1) return -1; // Left subtree unbalanced

    int rightHeight = checkHeight(root->right);
    if (rightHeight == -1) return -1; // Right subtree unbalanced

    if (abs(leftHeight - rightHeight) > 1)
        return -1; // Current node unbalanced

    return 1 + std::max(leftHeight, rightHeight);
}

